import subprocess as sp
import re
from typing import ParamSpec
import numpy as np
import numpy.fft as fft
import matplotlib.pyplot as plt
from lmfit import minimize, Parameters, Parameter, report_fit
import emcee
import corner
import scipy.optimize
import pandas as pd
import math
from matplotlib.widgets import Slider, Button, RadioButtons
from scipy import asarray as ar,exp
import NirspecTel_NIRSPEC2 as nt
import atmopt.rfm_tools as rfm
sys.path.insert(0, '../')
import pynirspec.pynirspec_python3 as pn

class Model():
	def __init__(self,**kwargs):
		self.Envi = rfm.Environment()
		self.rfm_exe = self.Envi.exe_file
		self.outname = 'rfm.tra'

	def RFM(self,**kwargs):
		self.makeDriverFile('rfm.drv',outname=self.outname,**kwargs)
		output = sp.check_output([self.rfm_exe])
		self.spectrum = self.readFromFile(self.outname)
		self.radiance = self.readFromFile('rfm.rad')
		return 1
		
	def makeDriverFile(self,filename,pwv=2.,am=1.05,wmin=2200.,wmax=2210.,
					   sampling=0.01,alt=4.15,
					   mols=['H2O','CO2','O3','CO','CH4'],
					   outname='rfm.tra',atm_files=None):

		if atm_files is None:
			atm_files = [self.Envi.atm_file]
		hitran_path = self.Envi.hit_file
		
		file = open(filename, 'w')

		file.write('*HDR\n		 ')
		file.write('RFM Driver file generated by RFM tools.\n')
		file.write('*FLG\n		 ')
		file.write('OBS TRA RAD ZEN DBL		 !\n')
		file.write('*SPC\n		 ')
		file.write(str(wmin)+' '+str(wmax)+' '+str(sampling)+'\n')
		file.write('*GAS\n		 ')
		for mol in mols:
			file.write(mol+' ')
		file.write('\n')
		file.write('*ATM\n		')
		for atm_file in atm_files:
			file.write(atm_file+'\n')
		file.write('*TAN\n		')
		file.write(str(am)+'\n')
		file.write('*HIT\n		')
		file.write(hitran_path+'\n')
		file.write('*OBS\n		')
		file.write(str(alt)+'\n')
		file.write('*TRA\n		')
		file.write(self.outname+'\n')
		file.write('*RAD\n		')
		file.write('rfm.rad\n')
		file.write('*END\n')

		file.close()

	def readFromFile(self,filename):
		
		ccond = re.compile('\!')
		
		file = open(filename,'r')
		lines = file.readlines()

		first_line_read = False

		data = np.array([])
		for line in lines:
			#Is it a comment line?
			if not ccond.search(line):
				#Is it the first line?
				if not first_line_read:
					first_line = line.split()
					npoints	 = int(first_line[0])
					wmin	 = float(first_line[1])
					sampling = float(first_line[2])
					wmax	 = float(first_line[3])
					label	 = first_line[4]
					label_len = len(label)
					#Remove inverted commas
					label = label[1:label_len-1]

					first_line_read = True
				else:
					data = np.append(data,[float(s) for s in line.split()])
 
		file.close()

		wave = np.linspace(wmin,wmax,npoints)

		#Everything in order of increasing wavelength
		return {'wavelength':1e4/wave[::-1],'wavenumber':wave[::-1],label:data[::-1]}
		
	def blur(self,rpower=1e5):
		wave = self.spectrum['wavelength']
		tran = self.spectrum['Transmission']
		radi = self.radiance['Radiance']
		
		wmin = wave.min()
		wmax = wave.max()
		
		nx = wave.size
		x  = np.arange(nx)
		
		A = wmin
		B = np.log(wmax/wmin)/nx
		wave_constfwhm = A*np.exp(B*x)

		tran_constfwhm = np.interp(wave_constfwhm, wave, tran)		  
		radi_constfwhm = np.interp(wave_constfwhm, wave, radi)	
		
		#Sanity check that the FWHM is indeed constant
		dwdx_constfwhm = np.diff(wave_constfwhm)
		fwhm_pix = wave_constfwhm[1:]/rpower/dwdx_constfwhm
		if (fwhm_pix.min()-fwhm_pix.max())/fwhm_pix.max() > 1e-5: 
			#This should not happen
			warnings.warn('The FWHM is not constant in units of pixels.')
		
		fwhm_pix  = fwhm_pix[0]
		sigma_pix = fwhm_pix/2.3548
		kx = np.arange(nx)-(nx-1)/2.
		kernel = 1./(sigma_pix*np.sqrt(2.*np.pi))*np.exp(-kx**2/(2.*sigma_pix**2)) 
		
		tran_conv = fft.ifft(fft.fft(tran_constfwhm)*np.conj(fft.fft(kernel)))
		tran_conv = fft.fftshift(tran_conv).real
		tran_oldsampling = np.interp(wave,wave_constfwhm,tran_conv)

		radi_conv = fft.ifft(fft.fft(radi_constfwhm)*np.conj(fft.fft(kernel)))
		radi_conv = fft.fftshift(radi_conv).real
		radi_oldsampling = np.interp(wave,wave_constfwhm,radi_conv)

		self.obs_spectrum = {'wavelength':wave,'wavenumber':1e4/wave, 
							 'Transmission':tran_oldsampling,'Radiance':radi_oldsampling}

		return self.obs_spectrum

	def getSpec(self):
		return self.obs_spectrum

	def plot(self,unit='cm-1'):
		if unit=='micron':
			plt.plot(self.obs_spectrum['wavelength'],self.obs_spectrum['Transmission'])
			plt.show()
		elif unit=='cm-1':
			plt.plot(self.obs_spectrum['wavenumber'],self.obs_spectrum['Transmission'])
			plt.show()
		else:
			raise Exception("Unknown unit in model plot")

class QuickRed():
	def __init__(self,flat_range=None, flat_dark_range=None, dark_range=None,
				sci_range=None, std_range=None, path=None, base=None,level1=True,level2=True,
				level1_path='L1FILES',shift=0.0, dtau=0.0, save_dark=False, save_flat=False, SettingsFile=None,
				sci_tname=None, std_tname=None, hold_plots=True, hold=True, **kwargs):

		if (hold == False):
			hold_plots = False

		self.save_dark = save_dark
		self.save_flat = save_flat

		sci_range1 = sci_range
		self.shift		 = shift
		self.dtau		 = dtau
		self.level1_path = level1_path

		self.SettingsFile = SettingsFile

		self.flat_dark_names = pn.makeFilelist(base,flat_dark_range,path=path)
		self.obs_dark_names	 = pn.makeFilelist(base,dark_range,path=path)
		self.flat_names		 = pn.makeFilelist(base,flat_range,path=path)
		self.sci_names1		 = pn.makeFilelist(base,sci_range1,path=path)
		self.std_names		 = pn.makeFilelist(base,std_range,path=path)

		self.mode  = 'SciStd'
		self.tdict = {'science':self.sci_names1,'standard':self.std_names}
		self.ndict = {'science':sci_tname, 'standard':std_tname}
		self.hold_plots = hold_plots

		if level1:
			self._level1()


	def _level1(self):
		FDark = pn.Dark(self.flat_dark_names)
		ODark = pn.Dark(self.obs_dark_names,save=self.save_dark)
		OFlat = pn.Flat(self.flat_names, dark=FDark,save=self.save_flat, SettingsFile=self.SettingsFile)

		level1_files = {}
		for key in self.tdict.keys():
			ONod	= pn.Nod(self.tdict[key],flat=OFlat,dark=ODark, tname=self.ndict[key], SettingsFile=self.SettingsFile) 
			norders = ONod.getNOrders()
			target_files = []
			for i in np.arange(norders):
				print ('### Processing order', i+1)
				OOrder	 = pn.Order(ONod,onum=i+1,write_path='foo')
				print ('### 2D order extracted')
				OSpec1D	 = pn.Spec1D(OOrder,sa=True,write_path='foo')
				OWaveCal = pn.WaveCal(OSpec1D.file,path='wave_o',am=OSpec1D.airmass, hp=self.hold_plots)


class WaveCal():
	def __init__(self, ObsFilename=None, wave_min=None, wave_max=None, FittingMethod='Polynomial', SetPointsFile=None,
					cull=50, am=1.0, H2O_scale=0.5, CO_scale=1,CO2_scale=0,_scale=0,CH4_scale=0,N2O_scale=0,O3_scale=0,OCS_scale=0,
					resolution=35000.,calibrationtype='tellurics',lamps=['Ar','Ne','Kr','Xe'],testlampsol=False,nirspec=2):
		
		self.nirspec = nirspec
		
		if calibrationtype == 'tellurics':
			## SETUP MODEL ATMOSPHERE ##
			Envi = rfm.Environment()
			A = rfm.Atmosphere(filename=Envi.atm_file)
			A.scaleProf('H2O', H2O_scale)
			A.scaleProf('CO', CO_scale)
			A.scaleProf('CH4', CH4_scale)
			A.scaleProf('CO2', CO2_scale)
			A.scaleProf('N2O', N2O_scale)
			A.scaleProf('O3', O3_scale)
			A.scaleProf('OCS', OCS_scale)
			A.writeAll('tmp.atm')
			self.A = A

			M = Model()
			M.RFM(atm_files=['tmp.atm'],wmin=1e4/wave_max,wmax=1e4/wave_min, am=am)
			M.blur(rpower=resolution)
			self.M = M
			#		 plt.figure()
			#		 plt.plot(self.M.spectrum['wavelength'], self.M.spectrum['Transmission']/np.mean(self.M.spectrum['Transmission']))
			#		 print self.M.spectrum['Transmission']
			#		 assert(0==1)

			## GET MODEL SKY SPECTRA ##
			ModInfo = M.getSpec()
			self.WaveMod  = ModInfo['wavelength']
			#		 self.SkyRadMod = ModInfo['Radiance'] / np.median(ModInfo['Radiance'])
			self.SkyRadMod = ModInfo['Radiance'] / np.amax(ModInfo['Radiance'])
			scale = np.amax(self.SkyRadMod)


			## GET OBSERVED SKY ##
			try:
				ObsInfo	   = nt.WaveOrder(ObsFilename,nirspec=self.nirspec).getData()
				WaveObsPos = np.array(ObsInfo['wl_pos'])
				SkyObsPos  = np.array(ObsInfo['sky_pos']) #/ np.median(ObsInfo['sky_pos'])	# L BAND
				#		 SkyObsPos	= np.array(ObsInfo['flux_pos']) / np.median(ObsInfo['flux_pos']) # K BAND
				WaveObsNeg = np.array(ObsInfo['wl_neg'])
				SkyObsNeg  = np.array(ObsInfo['sky_neg']) #/ np.median(ObsInfo['sky_neg'])  # L BAND
				#SkyObsNeg  = np.array(ObsInfo['sky_neg']) / np.median(ObsInfo['sky_neg'])  # L BAND
				#		 SkyObsNeg	= np.array(ObsInfo['flux_neg']) / np.median(ObsInfo['flux_neg']) # K BAND
			except:		
				### if running simulations (from dat files)
                                
                                ### (test)
                                from astropy.table import Table
                                specdata = Table.read(ObsFilename)
                                WaveObsPos = np.array(specdata['wave_pos'])
                                SkyObsPos  = np.array(specdata['sky_pos'])
                                WaveObsNeg = np.array(specdata['wave_neg'])
                                SkyObsNeg  = np.array(specdata['sky_neg'])
                        
                        # except:
			# 	spec = np.genfromtxt(ObsFilename,skip_header=1)
			# 	spec=np.transpose(spec)
			# 	spec[0] = 1e4/spec[0]
			# 	spec[0],spec[1] = spec[0][::-1],spec[1][::-1]
			# 	WaveObsPos, WaveObsNeg = spec[0],spec[0]
			# 	SkyObsPos, SkyObsNeg = spec[1],spec[1]
                        

			#plt.plot(WaveObsPos, SkyObsPos)
			#plt.show()

			FitOutContinuum = False 
			if FitOutContinuum:
				## FIT OUT CONTINUUM ## (DP 21 JAN 16)
				wn_data_all = [WaveObsPos, WaveObsNeg]
				flux_data_all = [SkyObsPos, SkyObsNeg]
				## for nirspec 1
				#merp = 16
				#factor = 64
				## for nirspec 2 
				merp = 32
				factor = 64
				posneg = 0
				baseline_pos, baseline_neg = np.ones(np.size(WaveObsPos)), np.ones(np.size(WaveObsNeg))
				#		 SkyObsPos_contrmv, SkyObsNeg_contrmv = np.array(np.size(SkyObsPos)), np.array(np.size(SkyObsNeg))
				for wn_data, flux_data in zip(wn_data_all, flux_data_all) : 
					points_flux, points_wn, points_count =np.zeros(merp), np.zeros(merp), np.arange(merp)
					for count in points_count :
						startpoint = count*factor
						endpoint = (count+1)*factor
						if count == 0 : startpoint = 10
						if count == 15 : endpoint = 2048-10
						points_flux[count]=np.min(flux_data[startpoint:endpoint])
						loc=np.argmax(flux_data[startpoint:endpoint])
			#				 points_wn[count]=wn_data[loc+startpoint]
						points_wn[count]=loc+startpoint
					coeff = np.polyfit(points_wn, points_flux, 1)	
					print (coeff)
		#			 if posneg == 0 : baseline_pos = coeff[1] + coeff[0]*wn_data# + coeff[1]*wn_data**2 + coeff[0]*wn_data**3
		#			 if posneg == 1 : baseline_neg = coeff[1] + coeff[0]*wn_data# + coeff[1]*wn_data**2 + coeff[0]*wn_data**3
		#			if posneg == 0 : baseline_pos = coeff[1] + coeff[0]*np.arange(2048)# + coeff[1]*np.arange(1024)**2 + coeff[0]*np.arange(1024)**3
		#			if posneg == 1 : baseline_neg = coeff[1] + coeff[0]*np.arange(2048)# + coeff[1]*np.arange(1024)**2 + coeff[0]*np.arange(1024)**3
					pix = np.arange(2048)
					if posneg == 0 : 
						fnc = np.poly1d(coeff)
						baseline_pos = fnc(pix)
					if posneg == 1 : 
						fnc = np.poly1d(coeff)
						baseline_neg = fnc(pix)
					posneg += 1
				SkyObsPos_contrmv, SkyObsNeg_contrmv = SkyObsPos / baseline_pos, SkyObsNeg / baseline_neg
		
			else:		
				SkyObsPos_contrmv, SkyObsNeg_contrmv = SkyObsPos, SkyObsNeg
	#		plt.figure()
	#		plt.plot(SkyObsPos, hold=True)
	#		plt.plot(baseline_pos, hold=True)
	#		plt.show()
	#		plt.figure()
	#		plt.plot(SkyObsNeg, hold=True)
	#		plt.plot(baseline_neg, hold=True)
	#		plt.show()
	#		#assert(1==0)
			
			
			self.ObsLabelPN = ['pos', 'neg']
			self.WaveObsPN = [WaveObsPos, WaveObsNeg]
			SkyObsPos_contrmv_scaled = SkyObsPos_contrmv / np.amax(SkyObsPos_contrmv) #scale * SkyObsPos_contrmv
			SkyObsNeg_contrmv_scaled = SkyObsNeg_contrmv / np.amax(SkyObsNeg_contrmv) #scale * SkyObsNeg_contrmv
			''' to flip data spectrum'''
			#SkyObsPos_contrmv_scaled = (SkyObsPos_contrmv_scaled - 1.0) * -1
			#SkyObsNeg_contrmv_scaled = (SkyObsNeg_contrmv_scaled - 1.0) * -1
			self.Pixels = [np.arange(len(WaveObsPos)), np.arange(len(WaveObsNeg))]
			self.SkyObsPN_orig	= [SkyObsPos, SkyObsNeg]
			self.SkyObsPN  = [SkyObsPos_contrmv_scaled, SkyObsNeg_contrmv_scaled]
	#		 print np.shape(self.SkyObsPN_orig)
	#		 print np.shape(SkyObsPos), np.shape(SkyObsNeg)
	#		 print np.shape(SkyObsPos_contrmv_scaled), np.shape(SkyObsNeg_contrmv_scaled)
	#		 print np.shape(self.SkyObsPN)
	#		 plt.figure()
	#		 plt.plot(SkyObsPos_contrmv_scaled)
	#		 plt.plot(self.SkyRadMod)
	#		 plt.show()
			
			#self.SkyObsPN[0][1018] = 0
			#self.SkyObsPN[0][1019] = 0
			#self.SkyObsPN[0] = self.SkyObsPN[0]/np.max(self.SkyObsPN[0])
			
			self.FittingMethod = FittingMethod
			if self.FittingMethod == 'Polynomial':
				self.GoodFit = [False, False]

				self.Coefs, self.WaveObsPN = self.FitInitDS(self.WaveObsPN, self.ObsLabelPN)
		
				#newwn = np.linspace(3.62,3.69,2048)
				#plt.figure()
				##plt.plot(self.WaveObsPN[0],self.SkyObsPN[0])
				#plt.plot(newwn,self.SkyObsPN[0])
				#plt.plot(self.WaveMod, self.SkyRadMod)
				#plt.figure()
				##plt.plot(self.WaveObsPN[1],self.SkyObsPN[1])
				#plt.plot(newwn,self.SkyObsPN[1])
				#plt.plot(self.WaveMod, self.SkyRadMod)
				#plt.show()
		
				while(True):
					RawInput = input('>> ').replace(" ", "").lower()

					if (RawInput == 'quit'):
						break

					if (RawInput == 'pos'):
						RawInput2 = input("Pos. Coefficients?: ").split(",")
						self.Coefs[0] = np.array(RawInput2, dtype=np.float)
						self.WaveObsPN[0] = self.DSFunc(self.Pixels[0], self.Coefs[0])
						self.PlotModObs(self.WaveMod, self.SkyRadMod, self.WaveObsPN[0], self.SkyObsPN[0], self.ObsLabelPN[0])
	
					if (RawInput == 'neg'):
						RawInput2 = input("Neg. Coefficients?: ").split(",")
						self.Coefs[1] = np.array(RawInput2, dtype=np.float)
						self.WaveObsPN[1] = self.DSFunc(self.Pixels[1], self.Coefs[1])
						self.PlotModObs(self.WaveMod, self.SkyRadMod, self.WaveObsPN[1], self.SkyObsPN[1], self.ObsLabelPN[1])

					if (RawInput == 'fit'):
						for i in range(0,len(self.Coefs)):
							if (self.GoodFit[i] != True):
								self.Coefs[i], self.WaveObsPN[i] = self.FitDS(self.WaveMod, self.SkyRadMod, self.SkyObsPN[i], self.Coefs[i])
								self.PlotModObs(self.WaveMod, self.SkyRadMod, self.WaveObsPN[i], self.SkyObsPN[i], self.ObsLabelPN[i])
								RawInput2 = input("Good Fit? (yes/no): ").replace(" ", "").lower()
								while (True):
									if (RawInput2 == 'yes'):
										self.GoodFit[i] = True
										break
									if (RawInput2 == 'no'):
										break
									else:
										print ("Please type yes or no.")
										break
							else:
								print ('')
								print ('## Dispersion Solution for ' + self.ObsLabelPN[i] + ' position is good.')

					if (RawInput == 'pf'):
						self.PrintCoefs()

			if self.FittingMethod == 'SetPoints':
				self.GoodFit = [False, False]
				self.CoefsInit = np.zeros([2,5])
				self.Coefs = np.zeros([2,5])
			
				### test old result on POS
				#www = self.DSFunc(np.arange(2048),[2.932984737348461, 2.5703414182770147e-05, 0.000924284966287049, -5.2335657756716884e-05, -2.306372056306791e-05])
				#plt.figure()			
				#plt.plot(self.WaveMod, self.SkyRadMod, color='blue', label='Model')
				#plt.plot(www, self.SkyObsPN[0], color='red', label='Data')
				#plt.show()
			
				while(True):
					RawInput = input('>> ').replace(" ", "").lower()
				
					if (RawInput == 'quit'):
						break
				
					if (RawInput == 'pos'):
						self.PlotModObs(self.WaveMod, self.SkyRadMod, self.Pixels[0], self.SkyObsPN[0], self.ObsLabelPN[0],twoplots=True)	
			
					if (RawInput == 'neg'):
						self.PlotModObs(self.WaveMod, self.SkyRadMod, self.Pixels[1], self.SkyObsPN[1], self.ObsLabelPN[1],twoplots=True)	
			
					if (RawInput == 'show'):
						for i in range(0,len(self.Pixels)):
							if i == 0:
								setpoints = np.genfromtxt(SetPointsFile,skip_header=1,usecols=(0,1))
							if i == 1:
								setpoints = np.genfromtxt(SetPointsFile,skip_header=1,usecols=(2,3))
							setpoints = np.transpose(setpoints)
							self.CoefsInit[i], self.WaveObsPN[i] = self.ConstructWave(self.Pixels[i],setpoints)
							self.PlotModObs(self.WaveMod, self.SkyRadMod, self.WaveObsPN[i], self.SkyObsPN[i], self.ObsLabelPN[i])
	
					if (RawInput == 'fit'):
						for i in range(0,len(self.Coefs)):
							if (self.GoodFit[i] != True):
								self.Coefs[i], self.WaveObsPN[i] = self.FitDS(self.WaveMod, self.SkyRadMod, self.SkyObsPN[i], self.CoefsInit[i])
								#self.Coefs[i], self.WaveObsPN[i] = self.FitDS_emcee(self.WaveMod, self.SkyRadMod, self.SkyObsPN[i], self.CoefsInit[i])
								self.PlotModObs(self.WaveMod, self.SkyRadMod, self.WaveObsPN[i], self.SkyObsPN[i], self.ObsLabelPN[i])
								RawInput2 = input("Good Fit? (yes/no): ").replace(" ", "").lower()
								while (True):
									if (RawInput2 == 'yes'):
										self.GoodFit[i] = True
										break
									if (RawInput2 == 'no'):
										break
									else:
										print ("Please type yes or no.")
										break
							else:
								print ('')
								print ('## Dispersion Solution for ' + self.ObsLabelPN[i] + ' position is good.')

					if (RawInput == 'pf'):
						self.PrintCoefs()

		if calibrationtype == 'lamp':
			## Get Lamp Models ##
			Ar,Ne,Kr,Xe = False, False, False, False
			if 'Ar' in lamps:
				Ar = True
			if 'Ne' in lamps:
				Ne = True
			if 'Kr' in lamps:
				Kr = True
			if 'Xe' in lamps:
				Xe = True		
				
			self.WaveMod, self.LampMod = self.GetLamps(Ne=Ne,Ar=Ar,Kr=Kr,Xe=Xe,resolution=resolution,wavemin=wave_min,wavemax=wave_max)
			self.LampMod = self.LampMod / np.max(self.LampMod)
			
			
			## GET OBSERVED SKY ##
			ObsInfo	   = nt.WaveOrder(ObsFilename).getData()
			WaveObsPos = np.array(ObsInfo['wl_pos'])
			LampObsPos  = np.array(ObsInfo['lamp_pos']) #/ np.mean(ObsInfo['lamp_pos'])	# L BAND
			WaveObsNeg = np.array(ObsInfo['wl_neg'])
			LampObsNeg  = np.array(ObsInfo['lamp_neg']) #/ np.mean(ObsInfo['lamp_neg'])  # L BAND
			
			'''
			### DEAL WITH SATURATED LINES ###
			### Ar from 10/17/2019
			#badpixranges_pos = [(772, 777), (1439, 1445), (1475, 1478)]
			#badpixranges_neg = [(772, 777), (1439, 1445), (1475, 1478)]
			### Xe from 01/07/2020
			badpixranges_pos = [(622, 648), (712, 734), (1363, 1375), (427, 434)]
			badpixranges_neg = [(622, 648), (712, 734), (1363, 1375), (427, 434)]
			# try interpolating between
			for xs in badpixranges_pos:
				ys = [LampObsPos[xs[0]], LampObsPos[xs[1]]]
				line = np.polyfit(xs,ys,1)
				fnc = np.poly1d(line)
				for ii in np.arange(xs[0]+1,xs[1]):
					LampObsPos[ii] = fnc(ii)
			for xs in badpixranges_neg:
				ys = [LampObsNeg[xs[0]], LampObsNeg[xs[1]]]
				line = np.polyfit(xs,ys,1)
				fnc = np.poly1d(line)
				for ii in np.arange(xs[0]+1,xs[1]):
					LampObsNeg[ii] = fnc(ii)
			'''


			'''
			FitOutContinuum = False 
			if FitOutContinuum:
				## FIT OUT CONTINUUM ## (DP 21 JAN 16)
				wn_data_all = [WaveObsPos, WaveObsNeg]
				flux_data_all = [SkyObsPos, SkyObsNeg]
				## for nirspec 1
				#merp = 16
				#factor = 64
				## for nirspec 2 
				merp = 32
				factor = 64
				posneg = 0
				baseline_pos, baseline_neg = np.ones(np.size(WaveObsPos)), np.ones(np.size(WaveObsNeg))
				#		 SkyObsPos_contrmv, SkyObsNeg_contrmv = np.array(np.size(SkyObsPos)), np.array(np.size(SkyObsNeg))
				for wn_data, flux_data in zip(wn_data_all, flux_data_all) : 
					points_flux, points_wn, points_count =np.zeros(merp), np.zeros(merp), np.arange(merp)
					for count in points_count :
						startpoint = count*factor
						endpoint = (count+1)*factor
						if count == 0 : startpoint = 10
						if count == 15 : endpoint = 2048-10
						points_flux[count]=np.min(flux_data[startpoint:endpoint])
						loc=np.argmax(flux_data[startpoint:endpoint])
			#				 points_wn[count]=wn_data[loc+startpoint]
						points_wn[count]=loc+startpoint
					coeff = np.polyfit(points_wn, points_flux, 1)	
					print (coeff)
		#			 if posneg == 0 : baseline_pos = coeff[1] + coeff[0]*wn_data# + coeff[1]*wn_data**2 + coeff[0]*wn_data**3
		#			 if posneg == 1 : baseline_neg = coeff[1] + coeff[0]*wn_data# + coeff[1]*wn_data**2 + coeff[0]*wn_data**3
		#			if posneg == 0 : baseline_pos = coeff[1] + coeff[0]*np.arange(2048)# + coeff[1]*np.arange(1024)**2 + coeff[0]*np.arange(1024)**3
		#			if posneg == 1 : baseline_neg = coeff[1] + coeff[0]*np.arange(2048)# + coeff[1]*np.arange(1024)**2 + coeff[0]*np.arange(1024)**3
					pix = np.arange(2048)
					if posneg == 0 : 
						fnc = np.poly1d(coeff)
						baseline_pos = fnc(pix)
					if posneg == 1 : 
						fnc = np.poly1d(coeff)
						baseline_neg = fnc(pix)
					posneg += 1
				SkyObsPos_contrmv, SkyObsNeg_contrmv = SkyObsPos / baseline_pos, SkyObsNeg / baseline_neg
		
			else:		
				SkyObsPos_contrmv, SkyObsNeg_contrmv = SkyObsPos, SkyObsNeg
	#		plt.figure()
	#		plt.plot(SkyObsPos, hold=True)
	#		plt.plot(baseline_pos, hold=True)
	#		plt.show()
	#		plt.figure()
	#		plt.plot(SkyObsNeg, hold=True)
	#		plt.plot(baseline_neg, hold=True)
	#		plt.show()
	#		#assert(1==0)
			'''
				
			self.ObsLabelPN = ['pos', 'neg']
			self.WaveObsPN = [WaveObsPos, WaveObsNeg]
			LampObsPos_norm = LampObsPos / np.amax(LampObsPos) #scale * SkyObsPos_contrmv
			LampObsNeg_norm = LampObsNeg / np.amax(LampObsNeg) #scale * SkyObsNeg_contrmv
			''' to flip data spectrum'''
			#SkyObsPos_contrmv_scaled = (SkyObsPos_contrmv_scaled - 1.0) * -1
			#SkyObsNeg_contrmv_scaled = (SkyObsNeg_contrmv_scaled - 1.0) * -1
			self.Pixels = [np.arange(len(WaveObsPos)), np.arange(len(WaveObsNeg))]
			self.LampObsPN_orig	= [LampObsPos, LampObsNeg]
			self.LampObsPN  = [LampObsPos_norm, LampObsNeg_norm]
	#		 print np.shape(self.SkyObsPN_orig)
	#		 print np.shape(SkyObsPos), np.shape(SkyObsNeg)
	#		 print np.shape(SkyObsPos_contrmv_scaled), np.shape(SkyObsNeg_contrmv_scaled)
	#		 print np.shape(self.SkyObsPN)
	#		 plt.figure()
	#		 plt.plot(SkyObsPos_contrmv_scaled)
	#		 plt.plot(self.SkyRadMod)
	#		 plt.show()
		
		
			if testlampsol:
				## 10/17/2019, from Ar lamps
				#LampPoints = [[(485.03004939387716, 		1.10819),
				#				(1791.6047008743215,	1.293673),
				#				(1416.3184506179973,	1.240622),
				#				(901.352497735899,		1.16719),
				#				(1627.2624302544255,	1.270576),
				#				(393.81644350571156,	1.095373),
				#				(741.5849304626156,		1.144497)],
				#				[(485.01399801589935,	1.10819),
				#					(1791.8554357851012,	1.293673),
				#					(1416.3179146177356,	1.240622),
				#					(901.3619144134187,		1.16719),
				#					(1627.2652835967394,	1.270576),
				#					(393.84842104211447,	1.095373),
				#					(741.6351469526162,	1.144497)]]		 
				## 1/7/2020, from Xe lamps
				LampPoints = [[(554.0416816332756,	0.968798),
									(1544.2765442380717,	1.108827),
									(954.686178766276,	1.025388),
									(1276.4512440244462,	1.070971),
									(794.3408637156845,	1.002647)],
								[(554.0296343823079,	0.968798),
									(1544.211781927239,	1.108827),
									(954.9903082579384,	1.025388),
									(1276.4072093411967,	1.070971),
									(794.3247446278953,	1.002647)]]	
				
				### 1/7/2021, from Xe lamps
				#LampPoints = [[(502.82451351300546,	0.968798),
				#					(1494.0948688394274, 1.108827),
				#					(787.0847781749421,	1.008755),
				#					(904.6642931335821,	1.025388),
				#					(1226.498507059439, 1.070971),
				#					(1359.5987041250944, 1.089831),
				#					(514.1832791414602, 0.970365),
				#					(1100.2614518978903, 1.053074)],
				#				[(502.8164981168694, 0.968798),
				#					(514.1651762362399,	0.970365),
				#					(787.0737168680608,	1.008755),
				#					(904.6838982769126,	1.025388),
				#					(1226.4962778892948, 1.070971),
				#					(1359.6178584289926, 1.089831),
				#					(1494.0870283094828, 1.108827),
				#					(1100.244002268128, 1.053074)]]						
				for i,lamponeside in enumerate(LampPoints):
					lamponeside = np.transpose(lamponeside)
					order = len(lamponeside[0])
					coefs = np.polyfit(lamponeside[0],lamponeside[1],order-1)
					print(coefs)
					fnc = np.poly1d(coefs)
					self.WaveObsPN[i] = fnc(self.Pixels[i])		
					self.PlotModObs_adjustable(self.WaveMod, self.LampMod, self.WaveObsPN[i], self.LampObsPN[i], self.ObsLabelPN[i])
				assert(1==0)		
		
		
			self.FittingMethod = FittingMethod
			if self.FittingMethod == 'Polynomial':
				self.GoodFit = [False, False]

				self.Coefs, self.WaveObsPN = self.FitInitDS(self.WaveObsPN, self.ObsLabelPN)
		
				#newwn = np.linspace(3.62,3.69,2048)
				#plt.figure()
				##plt.plot(self.WaveObsPN[0],self.SkyObsPN[0])
				#plt.plot(newwn,self.SkyObsPN[0])
				#plt.plot(self.WaveMod, self.SkyRadMod)
				#plt.figure()
				##plt.plot(self.WaveObsPN[1],self.SkyObsPN[1])
				#plt.plot(newwn,self.SkyObsPN[1])
				#plt.plot(self.WaveMod, self.SkyRadMod)
				#plt.show()
		
				while(True):
					RawInput = input('>> ').replace(" ", "").lower()

					if (RawInput == 'quit'):
						break

					if (RawInput == 'pos'):
						RawInput2 = input("Pos. Coefficients?: ").split(",")
						self.Coefs[0] = np.array(RawInput2, dtype=np.float)
						self.WaveObsPN[0] = self.DSFunc(self.Pixels[0], self.Coefs[0])
						self.PlotModObs(self.WaveMod, self.SkyRadMod, self.WaveObsPN[0], self.SkyObsPN[0], self.ObsLabelPN[0])
	
					if (RawInput == 'neg'):
						RawInput2 = input("Neg. Coefficients?: ").split(",")
						self.Coefs[1] = np.array(RawInput2, dtype=np.float)
						self.WaveObsPN[1] = self.DSFunc(self.Pixels[1], self.Coefs[1])
						self.PlotModObs(self.WaveMod, self.SkyRadMod, self.WaveObsPN[1], self.SkyObsPN[1], self.ObsLabelPN[1])

					if (RawInput == 'fit'):
						for i in range(0,len(self.Coefs)):
							if (self.GoodFit[i] != True):
								self.Coefs[i], self.WaveObsPN[i] = self.FitDS(self.WaveMod, self.SkyRadMod, self.SkyObsPN[i], self.Coefs[i])
								self.PlotModObs(self.WaveMod, self.SkyRadMod, self.WaveObsPN[i], self.SkyObsPN[i], self.ObsLabelPN[i])
								RawInput2 = input("Good Fit? (yes/no): ").replace(" ", "").lower()
								while (True):
									if (RawInput2 == 'yes'):
										self.GoodFit[i] = True
										break
									if (RawInput2 == 'no'):
										break
									else:
										print ("Please type yes or no.")
										break
							else:
								print ('')
								print ('## Dispersion Solution for ' + self.ObsLabelPN[i] + ' position is good.')

					if (RawInput == 'pf'):
						self.PrintCoefs()

			if self.FittingMethod == 'SetPoints':
				self.GoodFit = [False, False]
				self.CoefsInit = np.zeros([2,5])
				self.Coefs = np.zeros([2,5])
			
				### test old result on POS
				#www = self.DSFunc(np.arange(2048),[2.932984737348461, 2.5703414182770147e-05, 0.000924284966287049, -5.2335657756716884e-05, -2.306372056306791e-05])
				#plt.figure()			
				#plt.plot(self.WaveMod, self.SkyRadMod, color='blue', label='Model')
				#plt.plot(www, self.SkyObsPN[0], color='red', label='Data')
				#plt.show()
			
				while(True):
					RawInput = input('>> ').replace(" ", "").lower()
				
					if (RawInput == 'quit'):
						break
				
					if (RawInput == 'pos'):
						self.PlotModObs(self.WaveMod, self.LampMod, self.Pixels[0], self.LampObsPN[0], self.ObsLabelPN[0],twoplots=True)	
			
					if (RawInput == 'neg'):
						self.PlotModObs(self.WaveMod, self.LampMod, self.Pixels[1], self.LampObsPN[1], self.ObsLabelPN[1],twoplots=True)	
			
					if (RawInput == 'show'):
						for i in range(0,len(self.Pixels)):
							if i == 0:
								setpoints = np.genfromtxt(SetPointsFile,skip_header=1,usecols=(0,1))
							if i == 1:
								setpoints = np.genfromtxt(SetPointsFile,skip_header=1,usecols=(2,3))
							setpoints = np.transpose(setpoints)
							self.CoefsInit[i], self.WaveObsPN[i] = self.ConstructWave(self.Pixels[i],setpoints)
							self.PlotModObs_adjustable(self.WaveMod, self.LampMod, self.WaveObsPN[i], self.LampObsPN[i], self.ObsLabelPN[i])
	
					if (RawInput == 'fit'):
						for i in range(0,len(self.Coefs)):
							if (self.GoodFit[i] != True):
								self.Coefs[i], self.WaveObsPN[i] = self.FitDS(self.WaveMod, self.LampMod, self.LampObsPN[i], self.CoefsInit[i])
								#self.Coefs[i], self.WaveObsPN[i] = self.FitDS_emcee(self.WaveMod, self.SkyRadMod, self.SkyObsPN[i], self.CoefsInit[i])
								self.PlotModObs(self.WaveMod, self.LampMod, self.WaveObsPN[i], self.LampObsPN[i], self.ObsLabelPN[i])
								RawInput2 = input("Good Fit? (yes/no): ").replace(" ", "").lower()
								while (True):
									if (RawInput2 == 'yes'):
										self.GoodFit[i] = True
										break
									if (RawInput2 == 'no'):
										break
									else:
										print ("Please type yes or no.")
										break
							else:
								print ('')
								print ('## Dispersion Solution for ' + self.ObsLabelPN[i] + ' position is good.')

					if (RawInput == 'pf'):
						self.PrintCoefs()
			
			if self.FittingMethod == 'SetLampPositions':
				self.GoodFit = [False, False]
				self.CoefsInit = np.zeros([2,5])
				self.Coefs = np.zeros([2,5])
				self.RealCoefs_Pos, self.RealCoefs_Neg  = [], []
			
			
				while(True):
					RawInput = input('>> ').replace(" ", "").lower()
				
					if (RawInput == 'quit'):
						break
					
					
					if (RawInput == 'pos'):
						self.PlotModObs(self.WaveMod, self.LampMod, self.Pixels[0], self.LampObsPN[0], self.ObsLabelPN[0],twoplots=True)	
					
					
					if (RawInput == 'neg'):
						self.PlotModObs(self.WaveMod, self.LampMod, self.Pixels[1], self.LampObsPN[1], self.ObsLabelPN[1],twoplots=True)	
						
					
					if (RawInput == 'newline'):
						RawInput3 = input("Positive or Negative? ")
	
						if RawInput3 == 'pos':
							RawInput2 = input("Approximate Line Center, Wavelength: ").split(",")
							if RawInput2 != [""]:
								linecenterinput = int(RawInput2[0])
								linecenter = self.FitGaussian(self.Pixels[0][linecenterinput-3:linecenterinput+3],self.LampObsPN[0][linecenterinput-3:linecenterinput+3],linecenterinput)
								print(linecenter)
								self.RealCoefs_Pos.append([linecenter,float(RawInput2[1])])
						
						if RawInput3 == 'neg':
							RawInput2 = input("Approximate Line Center, Wavelength: ").split(",")
							if RawInput2 != [""]:
								linecenterinput = int(RawInput2[0])
								linecenter = self.FitGaussian(self.Pixels[1][linecenterinput-3:linecenterinput+3],self.LampObsPN[1][linecenterinput-3:linecenterinput+3],linecenterinput)
								print(linecenter)
								self.RealCoefs_Neg.append([linecenter,float(RawInput2[1])])
			
					
					if (RawInput == 'show'):
						for i in range(0,len(self.Pixels)):
							if i == 0:
								RealCoefs = self.RealCoefs_Pos
							if i == 1:
								RealCoefs = self.RealCoefs_Neg
							
							try:
								points = np.transpose(RealCoefs)
								order = len(points[0])
								coefs = np.polyfit(points[0],points[1],order-1)
								fnc = np.poly1d(coefs)
								self.WaveObsPN[i] = fnc(self.Pixels[i])							
								self.PlotModObs_adjustable(self.WaveMod, self.LampMod, self.WaveObsPN[i], self.LampObsPN[i], self.ObsLabelPN[i])
							except IndexError:
								print("Not enough "+self.ObsLabelPN[i]+" points")
						
						#for i in range(0,len(self.Pixels)):
						#	if i == 0:
						#		setpoints = np.genfromtxt(SetPointsFile,skip_header=1,usecols=(0,1))
						#	if i == 1:
						#		setpoints = np.genfromtxt(SetPointsFile,skip_header=1,usecols=(2,3))
						#	setpoints = np.transpose(setpoints)
						#	self.CoefsInit[i], self.WaveObsPN[i] = self.ConstructWave(self.Pixels[i],setpoints)
	
					#if (RawInput == 'fit'):
					#	for i in range(0,len(self.Coefs)):
					#		if (self.GoodFit[i] != True):
					#			self.Coefs[i], self.WaveObsPN[i] = self.FitDS(self.WaveMod, self.LampMod, self.LampObsPN[i], self.CoefsInit[i])
					#			#self.Coefs[i], self.WaveObsPN[i] = self.FitDS_emcee(self.WaveMod, self.SkyRadMod, self.SkyObsPN[i], self.CoefsInit[i])
					#			self.PlotModObs(self.WaveMod, self.LampMod, self.WaveObsPN[i], self.LampObsPN[i], self.ObsLabelPN[i])
					#			RawInput2 = input("Good Fit? (yes/no): ").replace(" ", "").lower()
					#			while (True):
					#				if (RawInput2 == 'yes'):
					#					self.GoodFit[i] = True
					#					break
					#				if (RawInput2 == 'no'):
					#					break
					#				else:
					#					print ("Please type yes or no.")
					#					break
					#		else:
					#			print ('')
					#			print ('## Dispersion Solution for ' + self.ObsLabelPN[i] + ' position is good.')


					if (RawInput == 'del'):
						RawInput2 = input("Positive? ")
						if RawInput2 != '':
							tempposcoefs = self.RealCoefs_Pos
							tempposcoefs = np.transpose(tempposcoefs)
							tempposcoefs[0] = np.abs(tempposcoefs[0]-float(RawInput2))	
							min = np.amin(tempposcoefs[0])
							tempposcoefs = np.transpose(tempposcoefs)
							for nn, i in enumerate(tempposcoefs):
								if i[0] == min:
									minind = nn
							del self.RealCoefs_Pos[minind]	
						
						RawInput2 = input("Negative? ")
						if RawInput2 != '':
							tempnegcoefs = self.RealCoefs_Neg
							tempnegcoefs = np.transpose(tempnegcoefs)
							tempnegcoefs[0] = np.abs(tempnegcoefs[0]-float(RawInput2))	
							min = np.amin(tempnegcoefs[0])
							tempnegcoefs = np.transpose(tempnegcoefs)
							for nn,i in enumerate(tempnegcoefs):
								if i[0] == min:
									minind = nn
							del self.RealCoefs_Neg[minind]
									 
						
					if (RawInput == 'pf'):
						#self.PrintCoefs()
						self.PrintLamps()

			

	def PrintCoefs(self):
		
		Clab = ['A = ', 'B = ', 'C = ', 'D = ', 'E = ']

		for coef, label, goodf in zip(self.Coefs,self.ObsLabelPN, self.GoodFit):
			print ('')
			print ('Position = ', label)
			print ('Good Fit = ', goodf)
			print ('-------------------')
			for i in range(0,len(coef)):
				print (Clab[i], coef[i])
			print ('')
			print ("{}, {}, {}, {}, {}".format(coef[0],coef[1],coef[2],coef[3],coef[4]))
			print ('')

	def PrintLamps(self):
		print("Positive :: ")	
		print("Pixel	Wavelength (microns)")	
	
		try:
			for i in self.RealCoefs_Pos:	
				print("{}	{}".format(i[0],i[1]))
				
			points = np.transpose(self.RealCoefs_Pos)
			order = len(points[0])
			coefs = np.polyfit(points[0],points[1],order-1)	
			print(coefs)
			
		except IndexError:
			print("Not enough positive points")
		
		print('###################')
		print('###################')
		
		print("Negative :: ")	
		print("Pixel	Wavelength (microns)")		

		try:	
			for i in self.RealCoefs_Neg:
				print("{}	{}".format(i[0],i[1]))
		
			points = np.transpose(self.RealCoefs_Neg)
			order = len(points[0])			
			coefs = np.polyfit(points[0],points[1],order-1)	
			print(coefs)
			
		except IndexError:
			print("Not enough negative points")
			

	def PlotModObs(self, wave_mod, flux_mod, wave_obs, flux_obs, label=None, twoplots=False, block=False):
		plt.close()
		plt.figure(figsize=(20, 10))
		plt.plot(wave_mod, flux_mod, color='blue',label="Model")
		if twoplots:
			x1,x2,y1,y2 = plt.axis()
			plt.axis((x1, x2, np.amin([np.amin(flux_mod), np.amin(flux_obs)]), np.amax(flux_obs)))
			plt.title(label)
			plt.legend(loc=0)
			plt.figure(figsize=(20, 10))
		plt.plot(wave_obs, flux_obs, color='red',label="Data")
		x1,x2,y1,y2 = plt.axis()
		plt.axis((x1, x2, np.amin([np.amin(flux_mod), np.amin(flux_obs)]), np.amax(flux_obs)))
		plt.title(label)
		plt.legend(loc=0)
		plt.show()
		#plt.savefig('/home/dpiskorz/Desktop/temp.pdf')

	
	def PlotModObs_adjustable(self, wave_mod, flux_mod, wave_obs, flux_obs, label, block=False):
		plt.close()
		'''
		plt.figure(figsize=(20, 10))
		#plt.plot(wave_mod, flux_mod, color='blue')
		self.plot_multicolored_lines(wave_mod,flux_mod,self.color)    ### this tells stel (c) vs tel (k) lines
		#plt.plot(wave_obs, flux_obs, color='red')
		x1,x2,y1,y2 = plt.axis()
		plt.axis((x1, x2, np.amin([np.amin(flux_mod), np.amin(flux_obs)])-0.15, np.amax(flux_mod)))
		plt.title(label)
		'''
  
		plt.figure(figsize=(20, 10))
		self.l, = plt.plot(wave_mod, flux_mod, color='blue')
		#self.plot_multicolored_lines(wave_mod,flux_mod,self.color)    ### this tells stel vs tel lines
		plt.plot(wave_obs, flux_obs, color='red')
		x1,x2,y1,y2 = plt.axis()
		plt.axis((x1, x2, np.nanmin([np.nanmin(flux_mod), np.nanmin(flux_obs)])-0.2, np.nanmax([np.amax(flux_obs),1.0])))
		plt.title(label)		
		
		axstell = plt.axes([0.25, 0.1, 0.55, 0.03])
		#axtell = plt.axes([0.25, 0.15, 0.55, 0.03])


		try:
			s0 = self.stell_val
		except AttributeError:	
			s0 = 1
			
		self.s_stell = Slider(axstell, 'Model Factor', 0.0, 30.0, valinit=s0)
		#self.s_tell = Slider(axtell, 'Telluric', 0.0, 10.0, valinit=t0)
		
		saveax = plt.axes([0.55, 0.025, 0.1, 0.04])
		button = Button(saveax, 'Save Values', hovercolor='0.975')
		
		self.s_stell.on_changed(self.update)
		#self.s_tell.on_changed(self.update)	

		button.on_clicked(self.save_ratios)
		
		resetax = plt.axes([0.35, 0.025, 0.1, 0.04])
		button2 = Button(resetax, 'Reset', hovercolor='0.975')
		button2.on_clicked(self.reset)
		
		plt.show()
		#plt.savefig('/home/cbuzard/Desktop/temp.pdf')
	
	def save_ratios(self,event):
		self.stell_val = self.stell
		#self.tell_val = self.tell
		print(self.stell_val)	#, self.tell_val
		#self.modflux = self.modspec.copy()  ### should update model to have ratios you pick everywhere
		self.LampMod = self.modspec.copy()  ### should update model to have ratios you pick everywhere
		
	def reset(self,event):
		self.s_stell.reset()
		#self.s_tell.reset()
				
	def update(self,val):
		self.stell = self.s_stell.val
		#self.tell = self.s_tell.val
		#if self.sec == 'full':
			#modspec = self.stell*self.StellFlux_Interp + self.tell*self.SkyRadMod	
		#else:
		#	stellflux, skyradmod = self.Breakintofour_better(self.StellFlux_Interp, self.SkyRadMod, section=self.sec)
		#	modspec = self.stell*stellflux + self.tell*skyradmod
		
		modspec = self.stell * self.LampMod
			
		#modspec = modspec / np.median(modspec)
		#self.modspec = 1 - modspec
	
		self.modspec = modspec
		self.l.set_ydata(self.modspec)	
	
	def ConstructWave(self,pixels,setpoints):
		## account for different number of points between pos + neg
		pix = setpoints[0][np.nonzero(setpoints[0])]
		wl = setpoints[1][np.nonzero(setpoints[1])]
		polyorder = len(pix)-1
		coefs = np.polyfit(pix,wl,polyorder)
		f = np.poly1d(coefs)
		Wave = f(pixels)
		
		coefs = list(coefs)[::-1]					## have to flip so it matches the other order
		while len(coefs) != len(self.Coefs[0]):		##self.Coefs[0] and [1] should be the same length
			coefs.append(1e-6)
		if coefs[2] == 1e-6:
			coefs[2] = 1e-5 
		#	params = Parameters()
		#	params.add('A',value=CoefsInit[0], vary=True,min=4.94, max=4.96)	## set ranges on this if necessary
		#	params.add('B',value=CoefsInit[1], vary=True)
		#	params.add('C',value=1e-5, vary=True)
		#	params.add('D',value=1e-6, vary=True)
		#	params.add('E',value=1e-6, vary=True)		
		print(coefs)
		
		return coefs, Wave
	
	
	def FitInitDS(self, WaveLengths, Labels):
		porder = 1
		Coefs, WaveLengths_fit = [], []

		print ('Initial Coefficients')
		print ('====================')

		for wl, label in zip(WaveLengths, Labels):
			pixels = np.arange(len(wl))

			coef = np.polyfit(pixels, wl, porder)[::-1]
			wl_fit = self.DSFunc(pixels, coef)

			print ('# ' + label + ' #')
			print ('---------------')
			for i in range(0, porder+1):
				print (i, coef[i])
			print ('')

			plt.plot(pixels, wl, 'ko')
			plt.plot(pixels, wl_fit)
			plt.show()

			Coefs.append(coef)
			WaveLengths_fit.append(wl_fit)

		return Coefs, WaveLengths_fit

	def DSFunc(self, pixels, Coefs):

		WaveOut = np.zeros(len(pixels))
		for i in range(0,len(Coefs)):
			if i <= 1:
				WaveOut = WaveOut + Coefs[i]*(pixels)**i
			else:
				WaveOut = WaveOut + Coefs[i]*(pixels/1000.)**i

		return WaveOut

	def residual(self, params, flux_data, wl_model, flux_model):
		npix = len(flux_data)
		pixels = np.arange(npix)
		
		try:
			Coefs = [params['A'].value, params['B'].value, params['C'].value, params['D'].value, params['E'].value]
		except:
			Coefs = list(params)
		wl_fit = self.DSFunc(pixels, Coefs)

		flux_model_fit = np.interp(wl_fit, wl_model, flux_model, left=flux_model[0], right=flux_model[-1])
			 
		#index_use = np.where(flux_data > 0.005)
		#residual = np.subtract(flux_model_fit[index_use], flux_data[index_use])

		residual = np.sum((np.subtract(flux_model_fit[10:-10], flux_data[10:-10]))**2.) 
		return (residual)

	def lnlike(self, params, flux_data, wl_model, flux_model):
		#print(params)
		npix = len(flux_data)
		pixels = np.arange(npix)
	
		#Coefs = [params['A'].value, params['B'].value, params['C'].value, params['D'].value, params['E'].value]
		#wl_fit = self.DSFunc(pixels, Coefs)
		#flux_model_fit = np.interp(wl_fit, wl_model, flux_model, left=flux_model[0], right=flux_model[-1])
		#index_use = np.where(flux_data > 0.005)
		#residual = np.subtract(flux_model_fit[index_use], flux_data[index_use])
		#return (residual)
		
		Coefs = params
		wl_fit = self.DSFunc(pixels, Coefs)
		flux_model_fit = np.interp(wl_fit, wl_model, flux_model, left=flux_model[0], right=flux_model[-1])
		
		### took this out because M band had lines below we want to include
		#index_use = np.where(flux_data > 0.005)
		#negresid = -0.5*np.sum(np.subtract(flux_model_fit[index_use], flux_data[index_use]))
		
		negresid = -0.5*np.sum((np.subtract(flux_model_fit[10:-10], flux_data[10:-10]))**2.)
		print (negresid)
		return (negresid)


	def FitDS(self, WLmod, Fmod, Fobs, CoefsInit):
		fitmethod = 'lmfit'	#'lmfit'
		if fitmethod == 'lmfit':
			if self.FittingMethod == 'Polynomial':
				params = Parameters()
				params.add('A',value=CoefsInit[0], vary=True) ## set ranges on this if necessary
				params.add('B',value=CoefsInit[1], vary=True)
				params.add('C',value=1e-5, vary=True)
				params.add('D',value=1e-6, vary=True)
				params.add('E',value=1e-6, vary=True) 
			if self.FittingMethod == 'SetPoints':
				params = Parameters()
				params.add('A',value=CoefsInit[0],vary=True)#min = 4.64, max = 4.65 )#,min=1.03,max=1.04) ## set ranges on this if necessary
				params.add('B',value=CoefsInit[1],vary=True)#min = 4e-5, max = 5e-5)
				params.add('C',value=CoefsInit[2],vary=True)
				params.add('D',value=CoefsInit[3], vary=True)
				params.add('E',value=CoefsInit[4], vary=True) 
			
			
			#print params
		#print '====='
		#print 'Fobs'
		#for p in Fobs: print p
		#print '====='
		#print 'WLmod'
		#for p in WLmod: print p
		#print '====='
		#print 'Fmod'
		#for p in Fmod: print p
			result = minimize(self.residual, params, args=(Fobs, WLmod, Fmod), method='powell') #'powell') #'least-sq')
	
			params = result.params
		
			print ('')
			print ('-----')
			#print report_fit(result)
			print ('A = ', params['A'])
			print ('B = ', params['B'] )
			print ('C = ', params['C'])
			print ('D = ', params['D'])
			print ('E = ', params['E'])
				#print 'R = ', params['R']
			print ('RedChi / Success = ', result.redchi, ' / ', result.success)
			print ('')
			print ('=====')
		
			#Coefs = result.x
			Coefs = [params['A'].value, params['B'].value, params['C'].value, params['D'].value, params['E'].value]
		
		'''
		if fitmethod == 'scipy':
			if self.FittingMethod == 'Polynomial':
				CoefsInit = np.array([CoefsInit[0],CoefsInit[1],1e-5,1e-6,1e-6])
			result = scipy.optimize.minimize(self.residual, np.array(CoefsInit), args=(Fobs, WLmod,Fmod), method='Powell',options={'xtol': 1e-8, 'disp': True})
			print(result.x)
			print(result.success)
			print(result.status)
			print(result.message)
			print(result.nit)
			Coefs = result.x
		'''
		pixels = np.arange(len(Fobs))
		WLobs = self.DSFunc(pixels, Coefs)

		return Coefs, WLobs

	def FitDS_emcee(self, WLmod, Fmod, Fobs, CoefsInit):
		
		if self.FittingMethod == 'Polynomial':
			CoefsInit = [CoefsInit[0],CoefsInit[1],1e-5,1e-6,1e-6]
		if self.FittingMethod == 'SetPoints':
			CoefsInit = CoefsInit													## already right length
		
		nwalkers = 100
		ndim = len(CoefsInit)		## 5 dimensions
		p0 = []
		for i in range(ndim):
			ci = 1e-4*CoefsInit[i]*np.random.randn(nwalkers)		#.reshape((nwalkers, ndim))
			ci = ci + CoefsInit[i]
			p0.append(ci)
		p0=np.array(p0) 
		p0=np.transpose(p0)
		
		sampler = emcee.EnsembleSampler(nwalkers, ndim, self.lnlike, args=[Fobs, WLmod, Fmod])
		#print(p0, sampler)
		pos, prob, state = sampler.run_mcmc(p0, 100)
		sampler.reset()

		sampler.run_mcmc(pos, 1000)
		samples = sampler.chain[:, 50:, :].reshape((-1, ndim))
		print("Mean acceptance fraction: {0:.3f}"
				.format(np.mean(sampler.acceptance_fraction)))		### want between 0.25 and 0.5
		Coefs = list(map(lambda v: (v[1]),zip(*np.percentile(samples, [16, 50, 84], axis=0))))
		CoefUncs = list(map(lambda v: (v[2]-v[1], v[1]-v[0]),zip(*np.percentile(samples, [16, 50, 84], axis=0))))
		
		print(Coefs)
		figure = corner.corner(samples,quantiles=[0.16,0.5,0.84],show_titles=True)
		plt.show()
		
		
		print ('')
		print ('-----')
		#print report_fit(result)
		print ('A = ', Coefs[0])
		print ('B = ', Coefs[1] )
		print ('C = ', Coefs[2])
		print ('D = ', Coefs[3])
		print ('E = ', Coefs[4])
		#print 'R = ', params['R']
		#print ('RedChi / Success = ', result.redchi, ' / ', result.success)
		print ('')
		print ('=====')
		
		#Coefs = result.x
		#Coefs = [params['A'].value, params['B'].value, params['C'].value, params['D'].value, params['E'].value]
		pixels = np.arange(len(Fobs))
		WLobs = self.DSFunc(pixels, Coefs)

		return Coefs, WLobs

	
	def Resolution(self,wave,data,resolution):	  

		### from TelCorPCA

		#terraspecip(specin, ip) :
		'''
			INPUT
		specin: input spectrum [2,n]
		ip: TERRASPEC ip coefficient array (DBLARR(9)
		ip[0]: width
		ip[1:4]: height of left satellite gaussians
		ip[5:8]: height of right satellite gaussians
		note that all 8 must be specified, even if zero.  ip[0] cannot be zero

		OUTPUT
		specout = specin*ip
		'''
		specin = np.array([wave,data])
		specin = specin.transpose()
   
		#if IP[0] != 0:
		#	ip = IP
		#else:
		ip = [0.028554, 0.000000, 0.000000, 0.000000, 0.000000, 0.200000, 0.200000, 0.010000, 0.010000]		## from 29oct2013, L band
   
		if resolution != 25000:
			ip[0] = ip[0]*25000/resolution
   

		# Check instrument profile
		nip=np.size(ip)
		if nip != 9 : print('IP has incorrect form')

		# Interpolate spectrum on an evenly spaced grid. 
		# Add padding necessary for Fourier convolution.
		specin[:,0] = 1.0e4 / specin[:,0]	## converts to wavenumbers
		spec_wv = specin[::-1, 0]
		spec_flux = specin[::-1, 1]	 
   
		#SaveTxtFiles(spec_wv, spec_flux, "/home/cbuzard/Code/BinProblem/pyini.dat")
   
		#assert(1==0)
		mn=np.size(spec_wv)
		mmin=np.amin(spec_wv)
		mmax=np.amax(spec_wv)
		mdelta=(mmax-mmin)/(mn-1)
		mx=np.arange(mn)*mdelta+mmin
		n=mn*2
		nexp=0
		while 2**nexp < n : nexp+=1
		npad=2**nexp
		m=np.zeros(npad)

		temp=np.interp(mx,spec_wv, spec_flux)
		m[0:np.size(temp)]=temp
   
		#print len(mx)
   
		#print npad
		#print mdelta

		# Generate the ordinate vector for the instrument profile
		#temp1=np.arange(math.ceil(npad/2.))*mdelta
		#ipx=np.r_[temp1,-temp1[::-1]]

		### CB changed to match IDL rountine exactly!!! 08/08/18
		temp1=np.arange(math.ceil(npad/2.))*mdelta
		temp2=(np.arange(math.ceil(npad/2.))+1)*mdelta*-1
		ipx=np.r_[temp1,temp2[::-1]]

		'''
		The height of the satellies (ip[1:7] are parameterized as percentages 
		is the height of the central gaussian. The height of the central gaussian 
		is determined such that the areab of the total IP is unity. ip[0] is sigma 
		for all gaussians.)
		'''

		#;;Avoid underflow errors - they are computationally expensive
		#tolerance = ALOG((MACHAR(/Double)).eps)
		tolerance=-36.043653389117154		# stolen from IDL

		# Calculate the height of the central gaussian
		h=1.0/(math.sqrt(2.0*math.pi)*ip[0]*(1.0+np.sum(ip[1:])))

		# Calculate the central gaussian
		z=-0.5*(ipx/ip[0])**2
		mask = z > tolerance
		central = np.zeros(np.size(mask))
		# changed to go faster
		#for ii in range(np.size(z)) : central[ii]=mask[ii]*h*math.exp(z[ii]*mask[ii])	  
		central[:] = mask[:]*h*np.exp(z[:]*mask[:])

		# Find satellite centers
		sc=ip[0]*math.sqrt(2.0*math.log(2.0))*np.array((-1.0,-2.0,-3.0,-4,1.0,2.0,3.0,4.0))

		# World's laziest matrix math to calculate satellite gaussians
		ipxspread=np.ones(8)
		first=np.outer(ipx,ipxspread)
		scspread=np.ones(npad)
		second=np.outer(scspread.T,sc.T)
		z=-0.5*((first-second)/ip[0])**2
		mask = z > tolerance
		npadspread=np.zeros(npad)+h
		ipspread=ip[1:]
		fake=np.outer(np.transpose(npadspread), np.transpose(ipspread))
		sat_temp=np.zeros(fake.shape)
		# changed to go faster
		#for kk in range(z.shape[0]) :
		#	 for jj in range(z.shape[1]) :
		#		 sat_temp[kk,jj]=fake[kk,jj]*mask[kk,jj]*math.exp(z[kk,jj]*mask[kk,jj])
		sat_temp[:,:] = fake[:,:]*mask[:,:]*np.exp(z[:,:]*mask[:,:])
		sat=np.sum(sat_temp,axis=1)

		# Complete instrumental profile
		ipy=central+sat
		#print ipy
		   
		#plt.plot(ipx,ipy)		## plots Gaussian kernel
		#plt.show()
   

		# Convolution of instrumental profile and model spectrum
		interim = np.fft.ifft(np.fft.fft(m)*np.fft.fft(ipy/ipy.sum(axis=0)))
		my = interim[:mn].real

		# Interpolate back onto original axis and adjust wavelength units
		broad_flux = np.interp(spec_wv,mx,my)[::-1]
		broad_wv = 1.0e4 / spec_wv[::-1]		

		return broad_wv, broad_flux
	
	
	def GetLamps(self,Ne=True,Ar=False,Kr=False,Xe=False,resolution=1000,wavemin=1,wavemax=3):
		
		file = "/home/cbuzard/Pipeline/01_Reduction/CalibrationwithLamps/nirspec-arclamps-masterlist.xlsx"	 
		lamps = pd.read_excel(file)
		wave = np.array(lamps["Wavelength (A in vac)"])
		flux = np.array(lamps["Counts (0.25sx15)"])
		lamptype = np.array(lamps["Arc Lamp"])	
		wave = wave / 1e4		## microns
		 
		if not Ne:
			index = np.where(lamptype=='Ne')
			wave = np.delete(wave,index)
			flux = np.delete(flux,index)
			lamptype = np.delete(lamptype,index)
			
		if not Ar:
			index = np.where(lamptype=='Ar')
			wave = np.delete(wave,index)
			flux = np.delete(flux,index)
			lamptype = np.delete(lamptype,index)
			
		if not Kr:
			index = np.where(lamptype=='Kr')
			wave = np.delete(wave,index)
			flux = np.delete(flux,index)
			lamptype = np.delete(lamptype,index)
			
		if not Xe:
			index = np.where(lamptype=='Xe')
			wave = np.delete(wave,index)
			flux = np.delete(flux,index)
			lamptype = np.delete(lamptype,index)
		

				
		fullwave = np.linspace(np.min(wave),np.max(wave),1e5)
		fullflux = np.zeros(len(fullwave))
		
		fullwave = np.concatenate([fullwave,wave])
		fullflux = np.concatenate([fullflux,flux])
		fullflux = fullflux[np.argsort(fullwave)]
		fullwave = fullwave[np.argsort(fullwave)]
		
		wave,flux = self.Resolution(fullwave,fullflux,resolution)
		
		newwave = np.linspace(wavemin,wavemax,1e4)
		newflux = np.interp(newwave,wave,flux)
	
		return newwave,newflux
		#return wave, flux
			
			
	def FitGaussian(self,x,y,linecenterinput):
		params = Parameters()
		params.add('A', value=1, vary=True)    
		params.add('B', value=linecenterinput, vary=True)
		params.add('C', value=3, vary=True)
		
		result_gauss = minimize(self.residual_gauss, params, args=(x,y), method='powell')
		params = result_gauss.params
		#bestfit_gauss = modelfunc_gauss(k, params['A'].value, params['B'].value, params['C'].value)
		#likelihood_gauss = likelihood(result_gauss.residual)
		#print 'GAUSS', params		
		
		return params['B'].value
	
	def modelfunc_gauss(self,x,a,x0,sigma) :
		return a * exp(-(x-x0)**2/(2*sigma**2))


	def residual_gauss(self,params, x, ydata) :
	    amp = params['A'].value
		ctr = params['B'].value
		sig = params['C'].value
		fit = self.modelfunc_gauss(x, amp, ctr, sig)
		delta = np.subtract(fit, ydata)
		delta = delta ** 2.
	    #residual = np.divide(delta,err)**2.
		return delta
	

class WaveCal_molecule():
	def __init__(self, wave_min=None, wave_max=None, cull=50, am=1.0, scale=[0.5,1.0,1.0,1.0,1.0,1.0,1.0], resolution=35000., mollist=['H2O', 'CO', 'CH4', 'CO2', 'N2O', 'O3', 'O2']):
		self.mollist = mollist
		
		### All together
		## SETUP MODEL ATMOSPHERE ##
		Envi = rfm.Environment()
		A = rfm.Atmosphere(filename=Envi.atm_file)
		for num, molecule in enumerate(self.mollist):
			mol_scale = scale[num]			
			A.scaleProf(molecule, mol_scale)
		A.writeAll('tmp.atm')
		self.A = A
	
		M = Model()
		M.RFM(atm_files=['tmp.atm'],wmin=1e4/wave_max,wmax=1e4/wave_min, am=am)
		M.blur(rpower=resolution)
		self.M = M
			
		## GET MODEL SKY SPECTRA ##
		ModInfo = M.getSpec()
		self.FullWaveMod  = ModInfo['wavelength']
		normalizer = np.median(ModInfo['Radiance'])
		self.FullSkyRadMod = ModInfo['Radiance'] / normalizer
#			self.SkyRadMod.append(ModInfo['Transmission'])	# / np.median(ModInfo['Transmission'])) # / np.amax(ModInfo['Radiance'])


		### molecules individually		
		self.SkyRadMod = []
		for num, molecule in enumerate(self.mollist):
#			if molecule == 'H2O':
#				mol_scale = H2O_scale
#			elif molecule == 'CO':
#				mol_scale = CO_scale
#			else:
#				mol_scale = 1.0 
			mol_scale = scale[num]			

			## SETUP MODEL ATMOSPHERE ##
			Envi = rfm.Environment()
			A = rfm.Atmosphere(filename=Envi.atm_file)
			A.scaleProf(molecule, mol_scale)
			fullmollist = ['NO','OCS','CH4','H2O','SO2','COF2','ClONO2','CO','HOCl','N2O','CO2','O2','F14','O3','C2H6','HCN','F22','HNO3','H2O2','NO2',
								'SF6','F12','HNO4','NH3','N2','CCl4','N2O5','F11','C2H2','ClO']
			for other in fullmollist:	#self.mollist:
				if other != molecule:
					A.scaleProf(other, 0)
			A.writeAll('tmp.atm')
			self.A = A
	
			M = Model()
			M.RFM(atm_files=['tmp.atm'],wmin=1e4/wave_max,wmax=1e4/wave_min, am=am)
			M.blur(rpower=resolution)
			self.M = M
			
			## GET MODEL SKY SPECTRA ##
			ModInfo = M.getSpec()
			self.WaveMod  = ModInfo['wavelength']
			#self.SkyRadMod = ModInfo['Radiance'] / np.median(ModInfo['Radiance'])
			skyradmod = ModInfo['Radiance'] / normalizer
			self.SkyRadMod.append(skyradmod)
#			self.SkyRadMod.append(ModInfo['Transmission'])	# / np.median(ModInfo['Transmission'])) # / np.amax(ModInfo['Radiance'])


